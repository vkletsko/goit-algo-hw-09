# goit-algo-hw-09

### Basics algorithms and Data Structures 
#### Master of degree from university

## Завдання

Необхідно написати дві функції для касової системи, яка видає решту покупцеві:

* Функція жадібного алгоритму find_coins_greedy. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми 113 це буде словник {50: 2, 10: 1, 2: 1, 1: 1}. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.

* Функція динамічного програмування find_min_coins. Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми 113 це буде словник {1: 1, 2: 1, 10: 1, 50: 2}

## Результат виконання

```
|----------------------------------|
|Алгоритм        | Час виконання   |
|----------------|-----------------|
|Greedy          | 0.00771         |
|----------------|-----------------|
|Min coins       | 7.24849         |
|----------------------------------|

Greedy в 939.64 разів швидший за Min coins.
```

## Висновок:
Жадібний алгоритм (Greedy) є значно швидшим за алгоритм динамічного програмування (Min coins). Час виконання жадібного алгоритму становить 0.00771 секунди, на відміну від алгоритму динамічного програмування, де час складає 7.24849 секунди. Greedy приблизно в 900 разів швидший за Min coins.

## Результат дослідження

Порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування залежить від конкретної задачі та умов, а також від розміру вхідних даних. Давайте розглянемо основні відмінності та ситуації, в яких один алгоритм може бути більш ефективним за інший:

1. Часова складність:
    * Жадібний алгоритм: Зазвичай має меншу часову складність, оскільки приймає локально оптимальні рішення на кожному кроці.
    * Алгоритм динамічного програмування: Зазвичай має більшу часову складність через необхідність обчислення та зберігання проміжних результатів для підзадач.
2. Простір пам'яті:
    * Жадібний алгоритм: Зазвичай вимагає менше простору пам'яті, оскільки зберігає лише поточний оптимальний варіант.
    * Алгоритм динамічного програмування: Може вимагати більше простору для зберігання проміжних результатів.
3. Оптимальність рішення:
    * Жадібний алгоритм: Не завжди гарантує знаходження глобально оптимального рішення, оскільки вибирає локально оптимальні варіанти на кожному етапі.
    * Алгоритм динамічного програмування: Забезпечує оптимальне рішення завдяки збереженню проміжних результатів.
4. Величина вхідних даних:
    * Жадібний алгоритм: Може бути більш ефективним при невеликих вхідних даних, оскільки не потребує обчислення та збереження багатьох проміжних результатів.
    * Алгоритм динамічного програмування: Стає більш вигідним при великих обсягах даних, оскільки його проміжні результати можуть бути використані для оптимізації великої кількості підзадач.

Загалом, вибір між жадібним алгоритмом та алгоритмом динамічного програмування залежить від конкретних вимог задачі та обсягу вхідних даних. Жадібні алгоритми часто використовуються там, де можна використовувати локальні оптимальні вибори без необхідності перегляду всієї проблеми. Алгоритми динамічного програмування найчастіше застосовуються в складних задачах з великою кількістю перекриваючихся підзадач, де можливо використовувати результати попередніх обчислень для оптимізації.